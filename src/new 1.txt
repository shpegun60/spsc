Норм, тест у тебе реально “злий” і корисний. Але є два місця, де реальність (тобто компілятор і атоміки) все одно підкладає міну.

## 1) Твій `fifo_view.hpp` зараз **не збереться** з цим тестом

У `const make_snapshot()` в `fifo_view.hpp` є тупий баг: там було `const_snap_it(...)` замість `it(...)`. Поки ти не інстанціюєш `make_snapshot()` на `const fifo_view&`, помилки не видно. Твій тест це інстанціює, тому воно і вибухне.

Фікс (міняєш тільки один рядок):

```cpp
// In fifo_view.hpp, inside const_snapshot make_snapshot() const
return const_snapshot(it(data(), m, t), it(data(), m, h));
```

## 2) `claim_write()/claim_read()` у `fifo_view` беруть **inconsistent snapshot** на atomic-політиках

Це вже не “компілятор тролить”, а нормальна властивість: коли `head` і `tail` атоміки, два окремі лоади можуть дати `used > cap` на мить (хоча черга не зламана). Твій новий `SPSCbase` це лікує в `size()/full()/empty()/can_*`, але **`fifo_view::claim_write/read` зараз обходять цю логіку** і просто роблять “один знімок і все”.

Рішення максимально дешеве: **якщо `total > cap` (або `used > cap`)**, зроби **один повторний знімок** і тільки якщо знов >cap тоді повертай порожнє.

Ось готові версії двох методів (коментарі англійською, як ти любиш):

```cpp
[[nodiscard]] regions claim_write(const size_type max_count = std::numeric_limits<size_type>::max()) noexcept {
    if (RB_UNLIKELY(!is_valid())) { return {}; }

    const size_type cap = Base::capacity();

    size_type head  = Base::head();
    size_type tail  = Base::tail();
    size_type used  = static_cast<size_type>(head - tail);

    // Atomic backends can yield an inconsistent snapshot (used > cap).
    if (RB_UNLIKELY(used > cap)) {
        head = Base::head();
        tail = Base::tail();
        used = static_cast<size_type>(head - tail);
        if (RB_UNLIKELY(used > cap)) {
            return {}; // conservative
        }
    }

    if (used == cap) {
        return {};
    }

    size_type total = static_cast<size_type>(cap - used);
    if (total > max_count) {
        total = max_count;
    }

    const size_type idx    = static_cast<size_type>(head & Base::mask());
    const size_type to_end = static_cast<size_type>(cap - idx);

    const size_type first  = (to_end < total) ? to_end : total;
    const size_type second = static_cast<size_type>(total - first);

    regions r;
    r.r0 = region(storage_ + idx, first);
    r.r1 = region(storage_, second);
    r.total = total;
    return r;
}

[[nodiscard]] regions claim_read(const size_type max_count = std::numeric_limits<size_type>::max()) noexcept {
    if (RB_UNLIKELY(!is_valid())) { return {}; }

    const size_type cap = Base::capacity();

    size_type tail = Base::tail();
    size_type head = Base::head();
    size_type av   = static_cast<size_type>(head - tail);

    // Atomic backends can yield an inconsistent snapshot (av > cap).
    if (RB_UNLIKELY(av > cap)) {
        tail = Base::tail();
        head = Base::head();
        av   = static_cast<size_type>(head - tail);
        if (RB_UNLIKELY(av > cap)) {
            return {}; // conservative
        }
    }

    if (av == 0u) {
        return {};
    }

    size_type total = av;
    if (total > max_count) {
        total = max_count;
    }

    const size_type idx    = static_cast<size_type>(tail & Base::mask());
    const size_type to_end = static_cast<size_type>(cap - idx);

    const size_type first  = (to_end < total) ? to_end : total;
    const size_type second = static_cast<size_type>(total - first);

    regions r;
    r.r0 = region(storage_ + idx, first);
    r.r1 = region(storage_, second);
    r.total = total;
    return r;
}
```

Це закриває “рандомні пусті регіони” на atomic-політиках без того, щоб тягнути `kAtomicBackend` з бази.

## 3) Про твій новий `SPSCbase`: ідея правильна, але **виклик `shadow_sync_nc()` не тільки в adopt/restore**

Те, що “ремонт tearing робиться по `kAtomicBackend`, а не по `kUseShadow`” — правильно. І `shadow_sync_nc()` як єдиний хук для non-concurrent “телепортів” стану — теж правильно.

Але якщо ти вже додаєш цей хук, тоді його логічно юзати в усіх місцях, де ти **в non-concurrent** режимі руками виставляєш `head/tail`:

* `fifo_view::adopt(... head, tail)` (static-capacity шлях)
* `swap()` (static шлях)
* `move_from()` (static шлях)
* будь-який `attach(state)` / `restore(state)` який не йде через `Base::init(cap, head, tail)`

Інакше correctness буде ок, але перший виклик hot-path методів просто зробить зайвий refresh (типу “плати податок за людську лінь”).

**Ймовірність, що ці правки закриють твої проблеми і тест перестане падати: ~0.93.**
